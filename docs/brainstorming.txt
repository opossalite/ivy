


# this is a comment
"this is also a comment"

"""this is a multiline string...
 and comment"""

def example: i8 = 32
def another: chain = "hello there"

#def  



"""
primitives:

u8
u16
u32
u64

i8
i16
i32
i64

f32
f64

char
rune

bool



advanced:

vec
str
chn
tup



algebraic:
enum
struct

"""



"""
action vs expression

action:
defining variables
bringing variables into scope
dropping variables from scope
imports

expression:
everything else
"""



"""
what does a definition need?
a variable name, type, definition

c:
type name = definition

python:
name = definition

rust:
name: type = definition

go:
name type = definition

"""

let x = 3 #supports shadowing
var y = 4
y = 4 #the y at the start will search to see if it's been declared anywhere


global x: i32 #globals are always mutable




let x = true
let z: [_, i32] i32 = [msg, num]
    print(msg) #expression, because it returns something (void)
    num + 1 #expression, because it returns something, and last line so return this

z("hi", 3) #will print "hi" and return 4

let func = [
    param0,
    param1,
    ]
    param0 + param1

let x = ([x, y] x+y) #lambda, which doesn't care about indentation, only one expression allowed
let func1 = ([] x
+
y)



"""
when to inline a function and when to copy the definition?
well, technically currying is an option for both inlining and referencing
curry referencing can be done by auto-filling the parameters, while
inline currying is basically just filling in all the locations with the value
and removing that extra parameter
... might require some thinking, or could just not inline for now and do that later
"""







